name: Integration Tests

on:
  push:
    branches: [main]
    paths:
      - 'deploy/kind/**'
      - 'Dockerfile.release'
      - 'cmd/**'
      - 'internal/**'
      - 'scripts/kind-e2e-test.sh'
      - '.github/workflows/integration.yml'
  pull_request:
    branches: [main]
    paths:
      - 'deploy/kind/**'
      - 'Dockerfile.release'
      - 'cmd/**'
      - 'internal/**'
      - 'scripts/kind-e2e-test.sh'
      - '.github/workflows/integration.yml'
  workflow_dispatch:

permissions:
  contents: read

env:
  GO_VERSION: "1.25"

jobs:
  kind-integration:
    name: KIND Integration Test
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v6

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Create KIND cluster
        uses: helm/kind-action@v1
        with:
          cluster_name: debrid-mount-monitor-ci
          wait: 120s

      - name: Build binary
        env:
          CGO_ENABLED: 0
          GOOS: linux
          GOARCH: amd64
        run: |
          go build -ldflags="-s -w" -o mount-monitor-linux-amd64 ./cmd/mount-monitor

      - name: Build Docker image from pre-built binary
        run: |
          mkdir -p docker-context
          cp mount-monitor-linux-amd64 docker-context/
          cp Dockerfile.release docker-context/
          docker build -t mount-monitor:dev -f docker-context/Dockerfile.release docker-context/

      - name: Verify image was built
        run: docker image inspect mount-monitor:dev > /dev/null

      - name: Load image into KIND
        run: kind load docker-image mount-monitor:dev --name debrid-mount-monitor-ci

      - name: Deploy monitor
        run: |
          kubectl apply -f deploy/kind/00-namespace.yaml
          kubectl apply -f deploy/kind/rbac.yaml
          kubectl apply -f deploy/kind/test-configmap.yaml
          kubectl apply -f deploy/kind/service.yaml
          kubectl apply -f deploy/kind/deployment.yaml

      - name: Wait for pod to be ready
        run: |
          kubectl -n mount-monitor-dev wait --for=condition=ready pod -l app=test-app-with-monitor --timeout=120s

      - name: Test liveness endpoint
        run: |
          POD=$(kubectl -n mount-monitor-dev get pod -l app=test-app-with-monitor -o jsonpath='{.items[0].metadata.name}')
          # Use main-app container (Alpine) since mount-monitor is scratch-based
          # /healthz/live returns HTTP 200 (no body) when healthy
          kubectl -n mount-monitor-dev exec $POD -c main-app -- wget -q --spider http://localhost:8080/healthz/live
          echo "Liveness endpoint OK"

      - name: Test readiness endpoint
        run: |
          POD=$(kubectl -n mount-monitor-dev get pod -l app=test-app-with-monitor -o jsonpath='{.items[0].metadata.name}')
          # /healthz/ready returns HTTP 200 (no body) when healthy
          kubectl -n mount-monitor-dev exec $POD -c main-app -- wget -q --spider http://localhost:8080/healthz/ready
          echo "Readiness endpoint OK"

      - name: Test status endpoint
        run: |
          POD=$(kubectl -n mount-monitor-dev get pod -l app=test-app-with-monitor -o jsonpath='{.items[0].metadata.name}')
          # /healthz/status returns JSON with "status":"healthy"
          kubectl -n mount-monitor-dev exec $POD -c main-app -- wget -q -O- http://localhost:8080/healthz/status | grep -q '"status":"healthy"'
          echo "Status endpoint OK"

      - name: Show monitor logs on failure
        if: failure()
        run: |
          echo "=== Pod status ==="
          kubectl -n mount-monitor-dev get pods
          echo "=== Pod description ==="
          kubectl -n mount-monitor-dev describe pods
          echo "=== Monitor logs ==="
          kubectl -n mount-monitor-dev logs -l app=test-app-with-monitor -c mount-monitor --tail=100 || true
